/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ds2021;

/**
 * STACK GENERICS IMPLEMENTATION
 * Identify methods that perform data processing vs pointer positioning
 * Because, generics affects data processing
 * Generics types in JAVA: 
 * <T> for type T (we keep to type T in this course)
 * <E> for elements E
 * <?> what is this??
 * <> they are called wrappers
 * @author Zati
 */

class GenericStack<T>{
    
    // declare some local variables for class Stack
    int maxSize;        // max size for our stack
    int top;            // this is our pointer, should point to the last position we left it
    T arr[];            // creating array of type String to contain String data
    

    public GenericStack(int n){
        this.maxSize = n;
        arr = (T[]) new Object[maxSize];          // now your array accepts any type of data 
        top = 0;                                  // top pointer initialize to index [0]
    }
    
    public boolean isEmpty(){
        if(top == 0){
            return true;
        }
        else{
            return false;
        }
    }
    
    public void push(T str){                    // push method must push type T only
        
        if (top < maxSize){                     // logic: only push data when stack in not full
            arr[top] = str;                     // where the pointer is, push only string value
            top++;                              // before leaving push method, put pointer to the next cell
        }
        else{
            System.out.println("Stack is full!!");
        }
    }
    
    public T pop(){             // pop() returns only type T
        if(!isEmpty()){
        // you can pop
            T temp = peek();            // temp should return only type T
            arr[top-1] = null;          // pop element
            top--;                      // before leaving pop method, decrease pointer below
            return temp;
        
        }
        else{
            return null;
        }
    }
    
    public T peek(){               // peek() now returns only type T
        
        //if (top > 0){                 // when top is not at 0, something has been pushed into the stack
        if(!isEmpty()){
            return arr[top-1];          // return the [top-1]
        }
        else{
            return null;                // otherwise, stack must be empty 
        }
    }
    
    public void displayArray(){
        for (int i = 0; i < top; i++) {
            System.out.println("[" + i + "]" + arr[top-i]);
        }
    }
    
}

public class App11 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // PUSH, POP, isEMPTY, PEEK
        GenericStack myStack = new GenericStack(4);       // we want stack to contain 4 elements
        myStack.push("banana");
        myStack.push(10);
        myStack.push(12.12);
        myStack.displayArray();
        
        GenericStack<String> gstack1 = new GenericStack<String>(10);
        gstack1.push("banana");
        gstack1.push("orange");
        gstack1.push("apple");
        gstack1.displayArray();
        
        GenericStack<Integer> gstack2 = new GenericStack<Integer>(5);
        gstack2.push(100);
        gstack2.push(200);
        gstack2.push(300);
        gstack2.push(400);
        gstack2.displayArray();
    }
    
}